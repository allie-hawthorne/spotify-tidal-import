<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>    
    const loadHandler = async () => {
      const clientId = localStorage.getItem('tidalClientId');
      const redirectUri = localStorage.getItem('tidalRedirectUri');

      if (clientId && redirectUri) {
        await init({
          clientId,
          credentialsStorageKey: 'authorisationCode',
        });

        if (window.location.search.length > 0) {
          await finalizeLogin(window.location.search);
          window.location.replace('/');
        } else {
          await getUserInfo();
          document.getElementById('searchField').style.display = 'block';
          document.getElementById('forceRefreshBtn').style.display = 'block';
        }
      }
    };

    window.addEventListener('load', loadHandler);

    // Below functions taken and adapted from @tidal-music/auth
    // This was so much worse than Spotify and at this point it might have just been easier to either do everything myself or just make this page a sub-project with all the bloat & awkwardness that comes with npm
    const TIDAL_LOGIN_SERVICE_BASE_URI = "https://login.tidal.com/";
    const TIDAL_AUTH_SERVICE_BASE_URI = "https://auth.tidal.com/v1/";
    const prefix = "AuthDB";

    const database = {
      getItem: (key) => {
        const result = globalThis.localStorage.getItem(`${prefix}/${key}`);
        return result ? stringToUint8Array(result) : void 0;
      },
      removeItem: (key) => {
        globalThis.localStorage.removeItem(`${prefix}/${key}`);
      },
      setItem: (key, data) => {
        globalThis.localStorage.setItem(`${prefix}/${key}`, bufferToString(data));
      }
    };

    const state = {
      pending: false,
      pendingPromises: []
    };

    const init = async ({
        clientId,
        clientSecret,
        clientUniqueKey,
        credentialsStorageKey,
        scopes,
        tidalAuthServiceBaseUri,
        tidalLoginServiceBaseUri,
    }) => {
      const persistedCredentials = await loadCredentials(credentialsStorageKey);
      const credentials = {
        ...persistedCredentials,
        clientId,
        credentialsStorageKey,
        // we store the clientSecret separately to determine if a token needs to be upgraded
        previousClientSecret: persistedCredentials?.clientSecret,
        scopes: scopes ?? [],
        tidalAuthServiceBaseUri: tidalAuthServiceBaseUri ?? persistedCredentials?.tidalAuthServiceBaseUri ?? TIDAL_AUTH_SERVICE_BASE_URI,
        tidalLoginServiceBaseUri: tidalLoginServiceBaseUri ?? persistedCredentials?.tidalLoginServiceBaseUri ?? TIDAL_LOGIN_SERVICE_BASE_URI
      };
      await persistCredentials(credentials);
      // await o.synchronize();
    };

    const loadCredentials = async (credentialsStorageKey) => {
      const { counter, encryptedCredentials, salt, wrappedKey } = getStorageItems(
        credentialsStorageKey
      );

      if (encryptedCredentials && counter && wrappedKey && salt) {
        try {
          const secretKey = await unwrapCryptoKey({
            password: credentialsStorageKey,
            salt,
            wrappedKeyBuffer: wrappedKey
          });
          const credentials = await decryptCredentials({
            counter,
            encryptedCredentials,
            key: secretKey
          });
          return JSON.parse(decodeCredentials(credentials));
        } catch (e) {
          console.error(e);
        }
      } else {
        return handleNewCryptoKey({
          password: credentialsStorageKey,
          storageKey: credentialsStorageKey
        });
      }
    };

    const persistCredentials = (updatedCredentials) => {
      state.credentials = updatedCredentials;
      const credentials = {
        ...state.credentials.accessToken,
        clientId: state.credentials.clientId,
        requestedScopes: state.credentials.scopes
      };
      // dispatchCredentialsUpdated(credentials);
      return saveCredentialsToStorage(state.credentials);
    };

    const saveCredentialsToStorage = async (credentials) => {
      const currentCredentials = await loadCredentials(
        credentials.credentialsStorageKey
      );
      const mergedCredentials = { ...currentCredentials, ...credentials };
      const { counter, salt, wrappedKey } = getStorageItems(credentials.credentialsStorageKey);
      if (!wrappedKey || !counter || !salt) {
        throw new e(authErrorCodeMap.storageError);
      }
      try {
        const secretKey = await unwrapCryptoKey({
          password: mergedCredentials.credentialsStorageKey,
          salt,
          wrappedKeyBuffer: wrappedKey
        });
        const encryptedCredentials = await encryptCredentials({
          content: encodeCredentials(JSON.stringify(mergedCredentials)),
          counter,
          key: secretKey
        });
        database.setItem(
          `${mergedCredentials.credentialsStorageKey}Data`,
          encryptedCredentials
        );
      } catch (error) {
        console.error(error);
        // throw new e(authErrorCodeMap.storageError, {cause: error});
      }
    };

    const getEncryptionKey = () => {
      return globalThis.crypto.subtle.generateKey(
        {
          length: 256,
          name: "AES-CTR"
        },
        true,
        ["encrypt", "decrypt"]
      );
    };

    const handleNewCryptoKey = async ({
      password,
      storageKey
    }) => {
      const key = await getEncryptionKey();
      const counter = globalThis.crypto.getRandomValues(new Uint8Array(16));
      const salt = globalThis.crypto.getRandomValues(new Uint8Array(16));
      const wrappedKey = await wrapCryptoKey({ keyToWrap: key, password, salt });
      try {
        database.setItem(`${storageKey}Counter`, counter);
        database.setItem(`${storageKey}Salt`, salt);
        database.setItem(`${storageKey}Key`, wrappedKey);
      } catch (error) {
        console.error(error);
        // throw new e(authErrorCodeMap.storageError, {cause: error});
      }
    };

    const getStorageItems = (credentialsStorageKey) => {
      return {
        counter: database.getItem(`${credentialsStorageKey}Counter`),
        encryptedCredentials: database.getItem(`${credentialsStorageKey}Data`),
        salt: database.getItem(`${credentialsStorageKey}Salt`),
        wrappedKey: database.getItem(`${credentialsStorageKey}Key`)
      };
    };

    const wrapCryptoKey = async ({
      keyToWrap,
      password,
      salt
    }) => {
      const keyMaterial = await getKeyMaterial(password);
      const wrappingKey = await getWrappingKey(keyMaterial, salt);
      return globalThis.crypto.subtle.wrapKey(
        "raw",
        keyToWrap,
        wrappingKey,
        "AES-KW"
      );
    };

    const unwrapCryptoKey = async ({
      password,
      salt,
      wrappedKeyBuffer
    }) => {
      const unwrappingKey = await getUnwrappingKey(salt, password);
      return globalThis.crypto.subtle.unwrapKey(
        "raw",
        wrappedKeyBuffer,
        unwrappingKey,
        "AES-KW",
        "AES-CTR",
        true,
        ["encrypt", "decrypt"]
      );
    };

    const getKeyMaterial = (password) => {
      const enc = new TextEncoder();
      return globalThis.crypto.subtle.importKey(
        "raw",
        enc.encode(password),
        { name: "PBKDF2" },
        false,
        ["deriveBits", "deriveKey"]
      );
    };

    const getWrappingKey = (keyMaterial, salt) => {
      return globalThis.crypto.subtle.deriveKey(
        {
          hash: "SHA-256",
          iterations: 1e5,
          name: "PBKDF2",
          salt
        },
        keyMaterial,
        { length: 256, name: "AES-KW" },
        true,
        ["wrapKey", "unwrapKey"]
      );
    };
    
    const getUnwrappingKey = async (salt, password) => {
      const keyMaterial = await getKeyMaterial(password);
      return getWrappingKey(keyMaterial, salt);
    };

    const encodeCredentials = (credentials) => {
      const textEnc = new TextEncoder();
      return textEnc.encode(credentials);
    };

    const decodeCredentials = (credentials) => {
      const textEnc = new TextDecoder();
      return textEnc.decode(credentials);
    };

    const encryptCredentials = ({
      content,
      counter,
      key
    }) => {
      return globalThis.crypto.subtle.encrypt(
        { counter, length: 64, name: "AES-CTR" },
        key,
        content
      );
    };

    const decryptCredentials = ({
      counter,
      encryptedCredentials,
      key
    }) => {
      return globalThis.crypto.subtle.decrypt(
        { counter, length: 64, name: "AES-CTR" },
        key,
        encryptedCredentials
      );
    };


    const finalizeLogin = async (loginResponseQuery) => {
      if (!state.credentials?.credentialsStorageKey || !state.credentials?.codeChallenge || !state.credentials?.redirectUri) {
        console.error('Missing credentials in state', state.credentials);
        throw new Error('Missing required credentials in state');
      }
      const {
        clientId,
        clientSecret,
        clientUniqueKey,
        codeChallenge,
        redirectUri,
        scopes
      } = state.credentials;
      const params = Object.fromEntries(new URLSearchParams(loginResponseQuery));
      if (!params.code) {
        throw new Error(authErrorCodeMap.authenticationError);
      }
      const body = {
        client_id: clientId,
        ...clientUniqueKey && {
          client_unique_key: clientUniqueKey
        },
        ...clientSecret && {
          client_secret: clientSecret
        },
        code: params.code,
        code_verifier: codeChallenge,
        grant_type: "authorization_code",
        redirect_uri: redirectUri,
        scope: scopes.join(" ")
      };
      const response = await handleTokenFetch({
        body,
        credentials: state.credentials
      });
      if (response instanceof Error) {
        throw response;
      }
      const jsonResponse = await response.json();
      await persistToken(jsonResponse);
      return;
    };

    const persistToken = async (jsonResponse) => {
      if (!state.credentials) {
        throw new Error(authErrorCodeMap.initError);
      }
      const { clientId, clientUniqueKey, scopes } = state.credentials;
      const grantedScopes = jsonResponse.scope?.length ? jsonResponse.scope?.split(" ") : [];
      const accessToken = {
        clientId,
        clientUniqueKey,
        // `expires_in` is sent in seconds, needs transformation to milliseconds
        expires: new Date().getTime() + jsonResponse.expires_in * 1e3,
        grantedScopes,
        requestedScopes: scopes,
        token: jsonResponse.access_token,
        ...jsonResponse.user_id && {
          userId: jsonResponse.user_id.toString()
        }
      };
      await persistCredentials({
        ...state.credentials,
        accessToken,
        // there is no refreshToken when renewing the accessToken
        ...jsonResponse.refresh_token && {
          refreshToken: jsonResponse.refresh_token
        }
      });
      return accessToken;
    };
    
    const handleTokenFetch = async ({
      body,
      credentials
    }) => {
      const { options, url } = prepareFetch({
        body,
        credentials,
        path: "oauth2/token"
      });
      const response = await exponentialBackoff({
        request: () => globalThis.fetch(url, options),
        // only retry in certain error cases
        retry: (res) => res.status >= 500 && res.status < 600
      });
      if (!response.ok) {
        return;
        // return await handleErrorResponse(response);
      }
      return response;
    };
    const prepareFetch = ({
      body,
      credentials,
      path
    }) => {
      const url = `${credentials.tidalAuthServiceBaseUri}${path}`;
      const options = {
        body: new URLSearchParams(body).toString(),
        headers: {
          "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
        },
        method: "POST"
      };
      return { options, url };
    };
    const exponentialBackoff = async ({
      delayInMs = 500,
      request,
      retry
    }) => {
      let base = 1;
      const limitReached = () => base > 32;
      while (!limitReached()) {
        await new Promise((resolve) => setTimeout(resolve, base * delayInMs));
        const result = await request();
        base *= 2;
        const shouldRetry = retry(result);
        if (!shouldRetry || limitReached()) {
          return result;
        }
      }
      throw new Error('Unexpected error');
    };

    function bufferToString(buf) {
      return String.fromCharCode(...new Uint8Array(buf));
    }
    function stringToUint8Array(str) {
      const buf = new ArrayBuffer(str.length);
      const bufView = new Uint8Array(buf);
      for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
      }
      return bufView;
    }
  </script>
</head>

<body>

</body>

</html>
